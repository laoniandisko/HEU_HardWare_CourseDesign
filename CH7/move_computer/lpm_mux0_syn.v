// megafunction wizard: %LPM_MUX%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: LPM_MUX 

// ============================================================
// File Name: lpm_mux0.v
// Megafunction Name(s):
// 			LPM_MUX
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 17.1.0 Build 590 10/25/2017 SJ Lite Edition
// ************************************************************


//Copyright (C) 2017  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel FPGA IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Intel and sold by Intel or its authorized distributors.  Please
//refer to the applicable agreement for further details.


//lpm_mux DEVICE_FAMILY="Cyclone IV GX" LPM_PIPELINE=1 LPM_SIZE=8 LPM_WIDTH=8 LPM_WIDTHS=3 aclr clken clock data result sel
//VERSION_BEGIN 17.1 cbx_lpm_mux 2017:10:25:18:06:53:SJ cbx_mgl 2017:10:25:18:08:29:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = lut 8 reg 19 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  lpm_mux0_mux
	( 
	aclr,
	clken,
	clock,
	data,
	result,
	sel) /* synthesis synthesis_clearbox=1 */;
	input   aclr;
	input   clken;
	input   clock;
	input   [63:0]  data;
	output   [7:0]  result;
	input   [2:0]  sel;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [63:0]  data;
	tri0   [2:0]  sel;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	dffe10;
	reg	dffe11;
	reg	dffe12;
	reg	dffe13;
	reg	dffe14;
	reg	dffe15;
	reg	dffe16;
	reg	dffe17;
	reg	[2:0]	dffe1a;
	reg	dffe2;
	reg	dffe3;
	reg	dffe4;
	reg	dffe5;
	reg	dffe6;
	reg	dffe7;
	reg	dffe8;
	reg	dffe9;
	wire  [7:0]  result_node;
	wire  [2:0]  sel_ffs_wire;
	wire  [2:0]  sel_node;
	wire  [3:0]  w_data107w;
	wire  [3:0]  w_data108w;
	wire  [7:0]  w_data13w;
	wire  [7:0]  w_data154w;
	wire  [3:0]  w_data176w;
	wire  [3:0]  w_data177w;
	wire  [7:0]  w_data223w;
	wire  [3:0]  w_data245w;
	wire  [3:0]  w_data246w;
	wire  [7:0]  w_data292w;
	wire  [3:0]  w_data314w;
	wire  [3:0]  w_data315w;
	wire  [3:0]  w_data35w;
	wire  [7:0]  w_data361w;
	wire  [3:0]  w_data36w;
	wire  [3:0]  w_data383w;
	wire  [3:0]  w_data384w;
	wire  [7:0]  w_data430w;
	wire  [3:0]  w_data452w;
	wire  [3:0]  w_data453w;
	wire  [7:0]  w_data499w;
	wire  [3:0]  w_data521w;
	wire  [3:0]  w_data522w;
	wire  [7:0]  w_data85w;
	wire  [1:0]  w_sel109w;
	wire  [1:0]  w_sel178w;
	wire  [1:0]  w_sel247w;
	wire  [1:0]  w_sel316w;
	wire  [1:0]  w_sel37w;
	wire  [1:0]  w_sel385w;
	wire  [1:0]  w_sel454w;
	wire  [1:0]  w_sel523w;

	// synopsys translate_off
	initial
		dffe10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe10 <= 1'b0;
		else if  (clken == 1'b1)   dffe10 <= (((w_data314w[1] & w_sel316w[0]) & (~ (((w_data314w[0] & (~ w_sel316w[1])) & (~ w_sel316w[0])) | (w_sel316w[1] & (w_sel316w[0] | w_data314w[2]))))) | ((((w_data314w[0] & (~ w_sel316w[1])) & (~ w_sel316w[0])) | (w_sel316w[1] & (w_sel316w[0] | w_data314w[2]))) & (w_data314w[3] | (~ w_sel316w[0]))));
	// synopsys translate_off
	initial
		dffe11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe11 <= 1'b0;
		else if  (clken == 1'b1)   dffe11 <= (((w_data315w[1] & w_sel316w[0]) & (~ (((w_data315w[0] & (~ w_sel316w[1])) & (~ w_sel316w[0])) | (w_sel316w[1] & (w_sel316w[0] | w_data315w[2]))))) | ((((w_data315w[0] & (~ w_sel316w[1])) & (~ w_sel316w[0])) | (w_sel316w[1] & (w_sel316w[0] | w_data315w[2]))) & (w_data315w[3] | (~ w_sel316w[0]))));
	// synopsys translate_off
	initial
		dffe12 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe12 <= 1'b0;
		else if  (clken == 1'b1)   dffe12 <= (((w_data383w[1] & w_sel385w[0]) & (~ (((w_data383w[0] & (~ w_sel385w[1])) & (~ w_sel385w[0])) | (w_sel385w[1] & (w_sel385w[0] | w_data383w[2]))))) | ((((w_data383w[0] & (~ w_sel385w[1])) & (~ w_sel385w[0])) | (w_sel385w[1] & (w_sel385w[0] | w_data383w[2]))) & (w_data383w[3] | (~ w_sel385w[0]))));
	// synopsys translate_off
	initial
		dffe13 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe13 <= 1'b0;
		else if  (clken == 1'b1)   dffe13 <= (((w_data384w[1] & w_sel385w[0]) & (~ (((w_data384w[0] & (~ w_sel385w[1])) & (~ w_sel385w[0])) | (w_sel385w[1] & (w_sel385w[0] | w_data384w[2]))))) | ((((w_data384w[0] & (~ w_sel385w[1])) & (~ w_sel385w[0])) | (w_sel385w[1] & (w_sel385w[0] | w_data384w[2]))) & (w_data384w[3] | (~ w_sel385w[0]))));
	// synopsys translate_off
	initial
		dffe14 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe14 <= 1'b0;
		else if  (clken == 1'b1)   dffe14 <= (((w_data452w[1] & w_sel454w[0]) & (~ (((w_data452w[0] & (~ w_sel454w[1])) & (~ w_sel454w[0])) | (w_sel454w[1] & (w_sel454w[0] | w_data452w[2]))))) | ((((w_data452w[0] & (~ w_sel454w[1])) & (~ w_sel454w[0])) | (w_sel454w[1] & (w_sel454w[0] | w_data452w[2]))) & (w_data452w[3] | (~ w_sel454w[0]))));
	// synopsys translate_off
	initial
		dffe15 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe15 <= 1'b0;
		else if  (clken == 1'b1)   dffe15 <= (((w_data453w[1] & w_sel454w[0]) & (~ (((w_data453w[0] & (~ w_sel454w[1])) & (~ w_sel454w[0])) | (w_sel454w[1] & (w_sel454w[0] | w_data453w[2]))))) | ((((w_data453w[0] & (~ w_sel454w[1])) & (~ w_sel454w[0])) | (w_sel454w[1] & (w_sel454w[0] | w_data453w[2]))) & (w_data453w[3] | (~ w_sel454w[0]))));
	// synopsys translate_off
	initial
		dffe16 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe16 <= 1'b0;
		else if  (clken == 1'b1)   dffe16 <= (((w_data521w[1] & w_sel523w[0]) & (~ (((w_data521w[0] & (~ w_sel523w[1])) & (~ w_sel523w[0])) | (w_sel523w[1] & (w_sel523w[0] | w_data521w[2]))))) | ((((w_data521w[0] & (~ w_sel523w[1])) & (~ w_sel523w[0])) | (w_sel523w[1] & (w_sel523w[0] | w_data521w[2]))) & (w_data521w[3] | (~ w_sel523w[0]))));
	// synopsys translate_off
	initial
		dffe17 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe17 <= 1'b0;
		else if  (clken == 1'b1)   dffe17 <= (((w_data522w[1] & w_sel523w[0]) & (~ (((w_data522w[0] & (~ w_sel523w[1])) & (~ w_sel523w[0])) | (w_sel523w[1] & (w_sel523w[0] | w_data522w[2]))))) | ((((w_data522w[0] & (~ w_sel523w[1])) & (~ w_sel523w[0])) | (w_sel523w[1] & (w_sel523w[0] | w_data522w[2]))) & (w_data522w[3] | (~ w_sel523w[0]))));
	// synopsys translate_off
	initial
		dffe1a = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe1a <= 3'b0;
		else if  (clken == 1'b1)   dffe1a <= sel[2:0];
	// synopsys translate_off
	initial
		dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe2 <= 1'b0;
		else if  (clken == 1'b1)   dffe2 <= (((w_data35w[1] & w_sel37w[0]) & (~ (((w_data35w[0] & (~ w_sel37w[1])) & (~ w_sel37w[0])) | (w_sel37w[1] & (w_sel37w[0] | w_data35w[2]))))) | ((((w_data35w[0] & (~ w_sel37w[1])) & (~ w_sel37w[0])) | (w_sel37w[1] & (w_sel37w[0] | w_data35w[2]))) & (w_data35w[3] | (~ w_sel37w[0]))));
	// synopsys translate_off
	initial
		dffe3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe3 <= 1'b0;
		else if  (clken == 1'b1)   dffe3 <= (((w_data36w[1] & w_sel37w[0]) & (~ (((w_data36w[0] & (~ w_sel37w[1])) & (~ w_sel37w[0])) | (w_sel37w[1] & (w_sel37w[0] | w_data36w[2]))))) | ((((w_data36w[0] & (~ w_sel37w[1])) & (~ w_sel37w[0])) | (w_sel37w[1] & (w_sel37w[0] | w_data36w[2]))) & (w_data36w[3] | (~ w_sel37w[0]))));
	// synopsys translate_off
	initial
		dffe4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe4 <= 1'b0;
		else if  (clken == 1'b1)   dffe4 <= (((w_data107w[1] & w_sel109w[0]) & (~ (((w_data107w[0] & (~ w_sel109w[1])) & (~ w_sel109w[0])) | (w_sel109w[1] & (w_sel109w[0] | w_data107w[2]))))) | ((((w_data107w[0] & (~ w_sel109w[1])) & (~ w_sel109w[0])) | (w_sel109w[1] & (w_sel109w[0] | w_data107w[2]))) & (w_data107w[3] | (~ w_sel109w[0]))));
	// synopsys translate_off
	initial
		dffe5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe5 <= 1'b0;
		else if  (clken == 1'b1)   dffe5 <= (((w_data108w[1] & w_sel109w[0]) & (~ (((w_data108w[0] & (~ w_sel109w[1])) & (~ w_sel109w[0])) | (w_sel109w[1] & (w_sel109w[0] | w_data108w[2]))))) | ((((w_data108w[0] & (~ w_sel109w[1])) & (~ w_sel109w[0])) | (w_sel109w[1] & (w_sel109w[0] | w_data108w[2]))) & (w_data108w[3] | (~ w_sel109w[0]))));
	// synopsys translate_off
	initial
		dffe6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe6 <= 1'b0;
		else if  (clken == 1'b1)   dffe6 <= (((w_data176w[1] & w_sel178w[0]) & (~ (((w_data176w[0] & (~ w_sel178w[1])) & (~ w_sel178w[0])) | (w_sel178w[1] & (w_sel178w[0] | w_data176w[2]))))) | ((((w_data176w[0] & (~ w_sel178w[1])) & (~ w_sel178w[0])) | (w_sel178w[1] & (w_sel178w[0] | w_data176w[2]))) & (w_data176w[3] | (~ w_sel178w[0]))));
	// synopsys translate_off
	initial
		dffe7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe7 <= 1'b0;
		else if  (clken == 1'b1)   dffe7 <= (((w_data177w[1] & w_sel178w[0]) & (~ (((w_data177w[0] & (~ w_sel178w[1])) & (~ w_sel178w[0])) | (w_sel178w[1] & (w_sel178w[0] | w_data177w[2]))))) | ((((w_data177w[0] & (~ w_sel178w[1])) & (~ w_sel178w[0])) | (w_sel178w[1] & (w_sel178w[0] | w_data177w[2]))) & (w_data177w[3] | (~ w_sel178w[0]))));
	// synopsys translate_off
	initial
		dffe8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe8 <= 1'b0;
		else if  (clken == 1'b1)   dffe8 <= (((w_data245w[1] & w_sel247w[0]) & (~ (((w_data245w[0] & (~ w_sel247w[1])) & (~ w_sel247w[0])) | (w_sel247w[1] & (w_sel247w[0] | w_data245w[2]))))) | ((((w_data245w[0] & (~ w_sel247w[1])) & (~ w_sel247w[0])) | (w_sel247w[1] & (w_sel247w[0] | w_data245w[2]))) & (w_data245w[3] | (~ w_sel247w[0]))));
	// synopsys translate_off
	initial
		dffe9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dffe9 <= 1'b0;
		else if  (clken == 1'b1)   dffe9 <= (((w_data246w[1] & w_sel247w[0]) & (~ (((w_data246w[0] & (~ w_sel247w[1])) & (~ w_sel247w[0])) | (w_sel247w[1] & (w_sel247w[0] | w_data246w[2]))))) | ((((w_data246w[0] & (~ w_sel247w[1])) & (~ w_sel247w[0])) | (w_sel247w[1] & (w_sel247w[0] | w_data246w[2]))) & (w_data246w[3] | (~ w_sel247w[0]))));
	assign
		result = result_node,
		result_node = {((sel_node[2] & dffe17) | ((~ sel_node[2]) & dffe16)), ((sel_node[2] & dffe15) | ((~ sel_node[2]) & dffe14)), ((sel_node[2] & dffe13) | ((~ sel_node[2]) & dffe12)), ((sel_node[2] & dffe11) | ((~ sel_node[2]) & dffe10)), ((sel_node[2] & dffe9) | ((~ sel_node[2]) & dffe8)), ((sel_node[2] & dffe7) | ((~ sel_node[2]) & dffe6)), ((sel_node[2] & dffe5) | ((~ sel_node[2]) & dffe4)), ((sel_node[2] & dffe3) | ((~ sel_node[2]) & dffe2))},
		sel_ffs_wire = {dffe1a},
		sel_node = {sel_ffs_wire[2], sel[1:0]},
		w_data107w = w_data85w[3:0],
		w_data108w = w_data85w[7:4],
		w_data13w = {data[56], data[48], data[40], data[32], data[24], data[16], data[8], data[0]},
		w_data154w = {data[58], data[50], data[42], data[34], data[26], data[18], data[10], data[2]},
		w_data176w = w_data154w[3:0],
		w_data177w = w_data154w[7:4],
		w_data223w = {data[59], data[51], data[43], data[35], data[27], data[19], data[11], data[3]},
		w_data245w = w_data223w[3:0],
		w_data246w = w_data223w[7:4],
		w_data292w = {data[60], data[52], data[44], data[36], data[28], data[20], data[12], data[4]},
		w_data314w = w_data292w[3:0],
		w_data315w = w_data292w[7:4],
		w_data35w = w_data13w[3:0],
		w_data361w = {data[61], data[53], data[45], data[37], data[29], data[21], data[13], data[5]},
		w_data36w = w_data13w[7:4],
		w_data383w = w_data361w[3:0],
		w_data384w = w_data361w[7:4],
		w_data430w = {data[62], data[54], data[46], data[38], data[30], data[22], data[14], data[6]},
		w_data452w = w_data430w[3:0],
		w_data453w = w_data430w[7:4],
		w_data499w = {data[63], data[55], data[47], data[39], data[31], data[23], data[15], data[7]},
		w_data521w = w_data499w[3:0],
		w_data522w = w_data499w[7:4],
		w_data85w = {data[57], data[49], data[41], data[33], data[25], data[17], data[9], data[1]},
		w_sel109w = sel_node[1:0],
		w_sel178w = sel_node[1:0],
		w_sel247w = sel_node[1:0],
		w_sel316w = sel_node[1:0],
		w_sel37w = sel_node[1:0],
		w_sel385w = sel_node[1:0],
		w_sel454w = sel_node[1:0],
		w_sel523w = sel_node[1:0];
endmodule //lpm_mux0_mux
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module lpm_mux0 (
	aclr,
	clken,
	clock,
	data0x,
	data1x,
	data2x,
	data3x,
	data4x,
	data5x,
	data6x,
	data7x,
	sel,
	result)/* synthesis synthesis_clearbox = 1 */;

	input	  aclr;
	input	  clken;
	input	  clock;
	input	[7:0]  data0x;
	input	[7:0]  data1x;
	input	[7:0]  data2x;
	input	[7:0]  data3x;
	input	[7:0]  data4x;
	input	[7:0]  data5x;
	input	[7:0]  data6x;
	input	[7:0]  data7x;
	input	[2:0]  sel;
	output	[7:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0	  aclr;
	tri1	  clken;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire [7:0] sub_wire9;
	wire [7:0] sub_wire8 = data0x[7:0];
	wire [7:0] sub_wire7 = data1x[7:0];
	wire [7:0] sub_wire6 = data2x[7:0];
	wire [7:0] sub_wire5 = data3x[7:0];
	wire [7:0] sub_wire4 = data4x[7:0];
	wire [7:0] sub_wire3 = data5x[7:0];
	wire [7:0] sub_wire2 = data6x[7:0];
	wire [7:0] sub_wire0 = data7x[7:0];
	wire [63:0] sub_wire1 = {sub_wire8, sub_wire7, sub_wire6, sub_wire5, sub_wire4, sub_wire3, sub_wire2, sub_wire0};
	wire [7:0] result = sub_wire9[7:0];

	lpm_mux0_mux	lpm_mux0_mux_component (
				.aclr (aclr),
				.clken (clken),
				.clock (clock),
				.data (sub_wire1),
				.sel (sel),
				.result (sub_wire9));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone IV GX"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "1"
// Retrieval info: PRIVATE: new_diagram STRING "1"
// Retrieval info: LIBRARY: lpm lpm.lpm_components.all
// Retrieval info: CONSTANT: LPM_PIPELINE NUMERIC "1"
// Retrieval info: CONSTANT: LPM_SIZE NUMERIC "8"
// Retrieval info: CONSTANT: LPM_TYPE STRING "LPM_MUX"
// Retrieval info: CONSTANT: LPM_WIDTH NUMERIC "8"
// Retrieval info: CONSTANT: LPM_WIDTHS NUMERIC "3"
// Retrieval info: USED_PORT: aclr 0 0 0 0 INPUT GND "aclr"
// Retrieval info: USED_PORT: clken 0 0 0 0 INPUT VCC "clken"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: USED_PORT: data0x 0 0 8 0 INPUT NODEFVAL "data0x[7..0]"
// Retrieval info: USED_PORT: data1x 0 0 8 0 INPUT NODEFVAL "data1x[7..0]"
// Retrieval info: USED_PORT: data2x 0 0 8 0 INPUT NODEFVAL "data2x[7..0]"
// Retrieval info: USED_PORT: data3x 0 0 8 0 INPUT NODEFVAL "data3x[7..0]"
// Retrieval info: USED_PORT: data4x 0 0 8 0 INPUT NODEFVAL "data4x[7..0]"
// Retrieval info: USED_PORT: data5x 0 0 8 0 INPUT NODEFVAL "data5x[7..0]"
// Retrieval info: USED_PORT: data6x 0 0 8 0 INPUT NODEFVAL "data6x[7..0]"
// Retrieval info: USED_PORT: data7x 0 0 8 0 INPUT NODEFVAL "data7x[7..0]"
// Retrieval info: USED_PORT: result 0 0 8 0 OUTPUT NODEFVAL "result[7..0]"
// Retrieval info: USED_PORT: sel 0 0 3 0 INPUT NODEFVAL "sel[2..0]"
// Retrieval info: CONNECT: @aclr 0 0 0 0 aclr 0 0 0 0
// Retrieval info: CONNECT: @clken 0 0 0 0 clken 0 0 0 0
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: @data 1 0 8 0 data0x 0 0 8 0
// Retrieval info: CONNECT: @data 1 1 8 0 data1x 0 0 8 0
// Retrieval info: CONNECT: @data 1 2 8 0 data2x 0 0 8 0
// Retrieval info: CONNECT: @data 1 3 8 0 data3x 0 0 8 0
// Retrieval info: CONNECT: @data 1 4 8 0 data4x 0 0 8 0
// Retrieval info: CONNECT: @data 1 5 8 0 data5x 0 0 8 0
// Retrieval info: CONNECT: @data 1 6 8 0 data6x 0 0 8 0
// Retrieval info: CONNECT: @data 1 7 8 0 data7x 0 0 8 0
// Retrieval info: CONNECT: @sel 0 0 3 0 sel 0 0 3 0
// Retrieval info: CONNECT: result 0 0 8 0 @result 0 0 8 0
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0.vhd TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0.inc TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0.cmp TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0.bsf TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0_inst.vhd TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mux0_syn.v TRUE
// Retrieval info: LIB_FILE: lpm
